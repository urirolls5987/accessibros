/**
 * Accessibility Widget Initialization Script
 * This script manages the state and behavior of an accessibility widget 
 * for font sizes, color adjustments, tools, and various content settings using cookies.
 */
document.addEventListener("DOMContentLoaded", function () {
  
  // Initial state for the widget
  let widgetState = { states: {} };

  /**
   * Save the widget state to a cookie
   */
  const saveStateToCookie = function () {
    const setCookie = function (stateObject) {
      const expirationDate = new Date();
      expirationDate.setTime(expirationDate.getTime() + (365 * 24 * 60 * 60 * 1000)); // Set the cookie to expire in 1 year
      const expires = "expires=" + expirationDate.toUTCString();
      document.cookie = "accessibility_widget=" + JSON.stringify(stateObject) + ";" + expires + ";path=/";
    };
    setCookie(widgetState);
  };

  /**
   * Load the widget state from the cookie
   * @returns {Object} Parsed widget state from the cookie or an empty object
   */
  const loadStateFromCookie = function () {
    const cookieName = "accessibility_widget=";
    const cookies = decodeURIComponent(document.cookie).split(";");

    for (let i = 0; i < cookies.length; i++) {
      let cookie = cookies[i].trim();
      if (cookie.indexOf(cookieName) === 0) {
        return JSON.parse(cookie.substring(cookieName.length, cookie.length));
      }
    }
    return {};
  };

  // Load saved state from the cookie, fallback to default state if unavailable
  try {
    widgetState = { states: {}, ...loadStateFromCookie() };
  } catch (error) {
    console.error("Error parsing widget state from cookie:", error);
  }

  // Predefined icons used in the widget
  const buttonIcons = ["format_size", "add", "remove", "restart_alt", "close"];

  /**
   * Generate HTML for the buttons in the widget
   * @param {Array} buttons - Array of button configurations (label, key, icon)
   * @param {String} additionalClass - Additional class for buttons (e.g., "asw-filter")
   * @returns {String} - HTML string for the buttons
   */
  const generateButtonHTML = function (buttons, additionalClass = "") {
    return buttons.map(({ label, key, icon }) => {
      const isSelected = widgetState.states[key] ? "asw-selected" : "";
      return `
        <div class="asw-btn ${additionalClass} ${isSelected}" 
             role="button" aria-pressed="${isSelected ? 'true' : 'false'}" 
             data-key="${key}" title="${label}">
          <span class="material-icons">${icon}</span>${label}
        </div>`;
    }).join("");
  };

  // Generate button HTML for content adjustments, color adjustments, and tools
  const contentAdjustmentButtons = generateButtonHTML([
    { label: "Readable Font", key: "readable-font", icon: "local_parking" },
    { label: "Highlight Links", key: "highlight-links", icon: "link" },
    { label: "Highlight Title", key: "highlight-title", icon: "title" }
  ]);

  const colorAdjustmentButtons = generateButtonHTML([
    { label: "Monochrome", key: "monochrome", icon: "filter_b_and_w" },
    { label: "Low Saturation", key: "low-saturation", icon: "gradient" },
    { label: "High Saturation", key: "high-saturation", icon: "filter_vintage" },
    { label: "High Contrast", key: "high-contrast", icon: "tonality" },
    { label: "Light Contrast", key: "light-contrast", icon: "brightness_5" },
    { label: "Dark Contrast", key: "dark-contrast", icon: "nightlight" }
  ], "asw-filter");

  const toolButtons = generateButtonHTML([
    { label: "Big Cursor", key: "big-cursor", icon: "mouse" },
    { label: "Stop Animations", key: "stop-animations", icon: "motion_photos_off" },
    { label: "Reading Guide", key: "readable-guide", icon: "local_library" }
  ], "asw-tools");

  // Create the widget container and populate it with content
  const widgetContainer = document.createElement("div");
  widgetContainer.innerHTML = `
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons&text=${buttonIcons.join(',')}" rel="stylesheet">
    <style>
      /* Place the widget's CSS here */
      /* This section should include styles for buttons, menu, etc. */
    </style>
    <div class="asw-widget">
      <div class="asw-menu-btn" title="Open Accessibility Menu" role="button" aria-expanded="false">
        <svg xmlns="http://www.w3.org/2000/svg" style="width:34px;height:34px;" viewBox="0 0 24 24">
          <path d="M0 0h24v24H0V0z" fill="none"/>
          <path d="M20.5 6c-2.61.7-5.67 1-8.5 1s-5.89-.3-8.5-1L3 8c1.86.5 4 .83 6 1v13h2v-6h2v6h2V9c2-.17 4.14-.5 6-1l-.5-2zM12 6c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"/>
        </svg>
      </div>
      <div class="asw-menu">
        <div class="asw-menu-header">
          Accessibility Menu
          <div>
            <div role="button" class="asw-menu-reset" title="Reset Settings">
              <span class="material-icons">restart_alt</span>
            </div>
            <div role="button" class="asw-menu-close" title="Close Accessibility Menu">
              <span class="material-icons">close</span>
            </div>
          </div>
        </div>
        <div class="asw-menu-content">
          <div class="asw-card">
            <div class="asw-card-title">Content Adjustments</div>
            <div class="asw-items">${contentAdjustmentButtons}</div>
          </div>
          <div class="asw-card">
            <div class="asw-card-title">Color Adjustments</div>
            <div class="asw-items">${colorAdjustmentButtons}</div>
          </div>
          <div class="asw-card">
            <div class="asw-card-title">Tools</div>
            <div class="asw-items">${toolButtons}</div>
          </div>
        </div>
        <div class="asw-footer"><a href="#">Brightways</a></div>
      </div>
      <div class="asw-overlay"></div>
    </div>
  `;

  /**
   * Update the style dynamically based on user selections
   * @param {String} filterKey - The key representing the filter to apply (e.g., high-contrast, monochrome)
   */
  const applyCSSFilter = function (filterKey) {
    let filterStyles = "";
    let cssRules = "";
    
    switch (filterKey) {
      case "dark-contrast":
        cssRules = "color: #fff !important; background-color: #000 !important;";
        break;
      case "light-contrast":
        cssRules = "color: #000 !important; background-color: #FFF !important;";
        break;
      case "high-contrast":
        cssRules = "contrast(125%)";
        break;
      case "high-saturation":
        cssRules = "saturate(200%)";
        break;
      case "low-saturation":
        cssRules = "saturate(50%)";
        break;
      case "monochrome":
        cssRules = "grayscale(100%)";
        break;
      default:
        cssRules = "";
    }

    filterStyles = `${filterKey} { ${cssRules} }`;
    addOrUpdateStyleSheet(filterStyles, "asw-filter-style");
  };

  /**
   * Add or update a stylesheet element in the document
   * @param {String} styles - CSS styles to insert or update
   * @param {String} id - The id for the style element
   */
  const addOrUpdateStyleSheet = function (styles, id) {
    let styleElement = document.getElementById(id) || document.createElement("style");
    styleElement.innerHTML = styles;
    if (!styleElement.id) {
      styleElement.id = id;
      document.head.appendChild(styleElement);
    }
  };

  // Attach event listeners to widget buttons and elements
  widgetContainer.querySelector(".asw-menu-btn").addEventListener("click", function () {
    const menu = widgetContainer.querySelector(".asw-menu");
    const overlay = widgetContainer.querySelector(".asw-overlay");
    menu.style.display = (menu.style.display === "block") ? "none" : "block";
    overlay.style.display = (menu.style.display === "block") ? "block" : "none";
  });

  widgetContainer.querySelector(".asw-menu-reset").addEventListener("click", function () {
    widgetState.states = {}; // Reset the state
    saveStateToCookie(); // Save the reset state
  });

  widgetContainer.querySelector(".asw-menu-close").addEventListener("click", function () {
    widgetContainer.querySelector(".asw-menu").style.display = "none";
    widgetContainer.querySelector(".asw-overlay").style.display = "none";
  });

  // Append the widget container to the document body
  document.body.appendChild(widgetContainer);

});
